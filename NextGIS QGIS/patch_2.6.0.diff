diff --git a/src/core/qgsexpressionparser.yy b/src/core/qgsexpressionparser.yy
index 458f9cc..9b22136 100644
--- a/src/core/qgsexpressionparser.yy
+++ b/src/core/qgsexpressionparser.yy
@@ -27,16 +27,9 @@
 // don't redeclare malloc/free
 #define YYINCLUDED_STDLIB_H 1
 
-struct expression_parser_context;
-#include "qgsexpressionparser.hpp"
-
 //! from lexer
-typedef void* yyscan_t;
-typedef struct yy_buffer_state* YY_BUFFER_STATE;
-extern int exp_lex_init(yyscan_t* scanner);
-extern int exp_lex_destroy(yyscan_t scanner);
-extern int exp_lex(YYSTYPE* yylval_param, yyscan_t yyscanner);
-extern YY_BUFFER_STATE exp__scan_string(const char* buffer, yyscan_t scanner);
+extern int exp_lex();
+extern void exp_set_input_buffer(const char* buffer);
 
 /** returns parsed tree, otherwise returns NULL and sets parserErrorMsg
     (interface function to be called from QgsExpression)
@@ -44,20 +37,12 @@ extern YY_BUFFER_STATE exp__scan_string(const char* buffer, yyscan_t scanner);
 QgsExpression::Node* parseExpression(const QString& str, QString& parserErrorMsg);
 
 /** error handler for bison */
-void exp_error(expression_parser_context* parser_ctx, const char* msg);
-
-struct expression_parser_context
-{
-  // lexer context
-  yyscan_t flex_scanner;
+void exp_error(const char* msg);
 
-  // varible where the parser error will be stored
-  QString errorMsg;
-  // root node of the expression
-  QgsExpression::Node* rootNode;
-};
+//! varible where the parser error will be stored
+QString gExpParserErrorMsg;
+QgsExpression::Node* gExpParserRootNode;
 
-#define scanner parser_ctx->flex_scanner
 
 // we want verbose error messages
 #define YYERROR_VERBOSE 1
@@ -66,11 +51,6 @@ struct expression_parser_context
 
 %}
 
-// make the parser reentrant
-%define api.pure
-%lex-param {void * scanner}
-%parse-param {expression_parser_context* parser_ctx}
-
 %name-prefix "exp_"
 
 %union
@@ -150,7 +130,7 @@ struct expression_parser_context
 
 %%
 
-root: expression { parser_ctx->rootNode = $1; }
+root: expression { gExpParserRootNode = $1; }
     ;
 
 expression:
@@ -182,13 +162,13 @@ expression:
           {
             // this should not actually happen because already in lexer we check whether an identifier is a known function
             // (if the name is not known the token is parsed as a column)
-            exp_error(parser_ctx, "Function is not known");
+            exp_error("Function is not known");
             YYERROR;
           }
           if ( QgsExpression::Functions()[fnIndex]->params() != -1
                && QgsExpression::Functions()[fnIndex]->params() != $3->count() )
           {
-            exp_error(parser_ctx, "Function is called with wrong number of arguments");
+            exp_error("Function is called with wrong number of arguments");
             YYERROR;
           }
           $$ = new QgsExpression::NodeFunction(fnIndex, $3);
@@ -215,7 +195,7 @@ expression:
           {
       if ( !QgsExpression::hasSpecialColumn( *$1 ) )
 	    {
-        exp_error(parser_ctx, "Special column is not known");
+	      exp_error("Special column is not known");
 	      YYERROR;
 	    }
 	    // $var is equivalent to _specialcol_( "$var" )
@@ -254,33 +234,28 @@ when_then_clause:
 
 %%
 
-
 // returns parsed tree, otherwise returns NULL and sets parserErrorMsg
 QgsExpression::Node* parseExpression(const QString& str, QString& parserErrorMsg)
 {
-  expression_parser_context ctx;
-  ctx.rootNode = 0;
-
-  exp_lex_init(&ctx.flex_scanner);
-  exp__scan_string(str.toUtf8().constData(), ctx.flex_scanner);
-  int res = exp_parse(&ctx);
-  exp_lex_destroy(ctx.flex_scanner);
+  gExpParserRootNode = NULL;
+  exp_set_input_buffer(str.toUtf8().constData());
+  int res = exp_parse();
 
   // list should be empty when parsing was OK
   if (res == 0) // success?
   {
-    return ctx.rootNode;
+    return gExpParserRootNode;
   }
   else // error?
   {
-    parserErrorMsg = ctx.errorMsg;
+    parserErrorMsg = gExpParserErrorMsg;
     return NULL;
   }
 }
 
 
-void exp_error(expression_parser_context* parser_ctx, const char* msg)
+void exp_error(const char* msg)
 {
-  parser_ctx->errorMsg = msg;
+  gExpParserErrorMsg = msg;
 }
 
diff --git a/src/core/qgsexpressionlexer.ll b/src/core/qgsexpressionlexer.ll
index c5db1ec..2036876 100644
--- a/src/core/qgsexpressionlexer.ll
+++ b/src/core/qgsexpressionlexer.ll
@@ -18,10 +18,6 @@
 %option never-interactive
 %option nounput
 %option prefix="exp_"
- // this makes flex generate lexer with context + init/destroy functions
-%option reentrant
- // this makes Bison send yylex another argument to use instead of using the global variable yylval
-%option bison-bridge
 
  // ensure that lexer will be 8-bit (and not just 7-bit)
 %option 8bit
@@ -31,7 +27,6 @@
 #include <stdlib.h>  // atof()
 
 #include "qgsexpression.h"
-struct expression_parser_context;
 #include "qgsexpressionparser.hpp"
 #include <QRegExp>
 #include <QLocale>
@@ -48,10 +43,10 @@ struct expression_parser_context;
 #define YY_NO_UNISTD_H
 #endif
 
-#define B_OP(x) yylval->b_op = QgsExpression::x
-#define U_OP(x) yylval->u_op = QgsExpression::x
-#define TEXT                   yylval->text = new QString(); *yylval->text = QString::fromUtf8(yytext);
-#define TEXT_FILTER(filter_fn) yylval->text = new QString(); *yylval->text = filter_fn( QString::fromUtf8(yytext) );
+#define B_OP(x) exp_lval.b_op = QgsExpression::x
+#define U_OP(x) exp_lval.u_op = QgsExpression::x
+#define TEXT                   exp_lval.text = new QString(); *exp_lval.text = QString::fromUtf8(yytext);
+#define TEXT_FILTER(filter_fn) exp_lval.text = new QString(); *exp_lval.text = filter_fn( QString::fromUtf8(yytext) );
 
 static QString stripText(QString text)
 {
@@ -110,7 +105,7 @@ column_ref_quoted  "\""{col_str_char}*"\""
 
 dig         [0-9]
 num_int     {dig}+
-num_float   {dig}*(\.{dig}+([eE][-+]?{dig}+)?|[eE][-+]?{dig}+)
+num_float   {dig}*\.{dig}+([eE][-+]?{dig}+)?
 
 str_char    ('')|(\\.)|[^'\\]
 string      "'"{str_char}*"'"
@@ -159,14 +154,14 @@ string      "'"{str_char}*"'"
 
 ","   { return COMMA; }
 
-{num_float}  { yylval->numberFloat = cLocale.toDouble( QString::fromAscii(yytext) ); return NUMBER_FLOAT; }
+{num_float}  { exp_lval.numberFloat  = cLocale.toDouble( QString::fromAscii(yytext) ); return NUMBER_FLOAT; }
 {num_int}  {
 	bool ok;
-	yylval->numberInt = cLocale.toInt( QString::fromAscii(yytext), &ok, 10 );
+	exp_lval.numberInt = cLocale.toInt( QString::fromAscii(yytext), &ok, 10 );
 	if( ok )
 		return NUMBER_INT;
 
-	yylval->numberFloat = cLocale.toDouble( QString::fromAscii(yytext), &ok );
+	exp_lval.numberFloat  = cLocale.toDouble( QString::fromAscii(yytext), &ok );
 	if( ok )
 		return NUMBER_FLOAT;
 
@@ -177,7 +172,7 @@ string      "'"{str_char}*"'"
 
 {special_col}        { TEXT; return SPECIAL_COL; }
 
-{column_ref}         { TEXT; return QgsExpression::isFunctionName(*yylval->text) ? FUNCTION : COLUMN_REF; }
+{column_ref}         { TEXT; return QgsExpression::isFunctionName(*exp_lval.text) ? FUNCTION : COLUMN_REF; }
 
 {column_ref_quoted}  { TEXT_FILTER(stripColumnRef); return COLUMN_REF; }
 
@@ -186,3 +181,9 @@ string      "'"{str_char}*"'"
 .       { return Unknown_CHARACTER; }
 
 %%
+
+void exp_set_input_buffer(const char* buffer)
+{
+  exp__scan_string(buffer);
+}
+
diff --git a/tests/src/core/testqgsexpression.cpp b/tests/src/core/testqgsexpression.cpp
index 492c67e..7c4ba85 100644
--- a/tests/src/core/testqgsexpression.cpp
+++ b/tests/src/core/testqgsexpression.cpp
@@ -16,8 +16,6 @@
 #include <QObject>
 #include <QString>
 #include <QObject>
-#include <QtConcurrentMap>
-
 #include <qgsapplication.h>
 //header for class being tested
 #include <qgsexpression.h>
@@ -31,16 +29,6 @@
 Q_DECLARE_METATYPE( QVariant )
 #endif
 
-static void _parseAndEvalExpr( int arg )
-{
-  Q_UNUSED( arg );
-  for ( int i = 0; i < 100; ++i )
-  {
-    QgsExpression exp( "1 + 2 * 2" );
-    exp.evaluate();
-  }
-}
-
 class TestQgsExpression: public QObject
 {
     Q_OBJECT;
@@ -148,9 +136,6 @@ class TestQgsExpression: public QObject
       QTest::newRow( "literal int" ) << "123" << false << QVariant( 123 );
       QTest::newRow( "literal double" ) << "1.2" << false << QVariant( 1.2 );
       QTest::newRow( "literal text" ) << "'hello'" << false << QVariant( "hello" );
-      QTest::newRow( "literal double" ) << ".000001" << false << QVariant( 0.000001 );
-      QTest::newRow( "literal double" ) << "1.0e-6" << false << QVariant( 0.000001 );
-      QTest::newRow( "literal double" ) << "1e-6" << false << QVariant( 0.000001 );
 
       // unary minus
       QTest::newRow( "unary minus double" ) << "-1.3" << false << QVariant( -1.3 );
@@ -267,8 +252,8 @@ class TestQgsExpression: public QObject
       QTest::newRow( "log10(100)" ) << "log10(100)" << false << QVariant( 2. );
       QTest::newRow( "log(2,32)" ) << "log(2,32)" << false << QVariant( 5. );
       QTest::newRow( "log(10,1000)" ) << "log(10,1000)" << false << QVariant( 3. );
-      QTest::newRow( "log(-2,32)" ) << "log(-2,32)" << false << QVariant();
-      QTest::newRow( "log(2,-32)" ) << "log(2,-32)" << false << QVariant();
+      QTest::newRow( "log(-2,32)" ) << "log(-2,32)" << false << QVariant( );
+      QTest::newRow( "log(2,-32)" ) << "log(2,-32)" << false << QVariant( );
       QTest::newRow( "log(0.5,32)" ) << "log(0.5,32)" << false << QVariant( -5. );
       QTest::newRow( "round(1234.557,2) - round up" ) << "round(1234.557,2)" << false << QVariant( 1234.56 );
       QTest::newRow( "round(1234.554,2) - round down" ) << "round(1234.554,2)" << false << QVariant( 1234.55 );
@@ -353,7 +338,7 @@ class TestQgsExpression: public QObject
       QTest::newRow( "condition else" ) << "case when 1=0 then 'bad' else 678 end" << false << QVariant( 678 );
       QTest::newRow( "condition null" ) << "case when length(123)=0 then 111 end" << false << QVariant();
       QTest::newRow( "condition 2 when" ) << "case when 2>3 then 23 when 3>2 then 32 else 0 end" << false << QVariant( 32 );
-      QTest::newRow( "coalesce null" ) << "coalesce(NULL)" << false << QVariant();
+      QTest::newRow( "coalesce null" ) << "coalesce(NULL)" << false << QVariant( );
       QTest::newRow( "coalesce mid-null" ) << "coalesce(1, NULL, 3)" << false << QVariant( 1 );
       QTest::newRow( "coalesce exp" ) << "coalesce(NULL, 1+1)" << false << QVariant( 2 );
       QTest::newRow( "regexp match" ) << "regexp_match('abc','.b.')" << false << QVariant( 1 );
@@ -961,15 +946,6 @@ class TestQgsExpression: public QObject
       QCOMPARE( QgsExpression::quotedString( "hello\\world" ), QString( "'hello\\\\world'" ) );
     }
 
-    void reentrant()
-    {
-      // this simply should not crash
-
-      QList<int> lst;
-      for ( int i = 0; i < 10; ++i )
-        lst << i;
-      QtConcurrent::blockingMap( lst, _parseAndEvalExpr );
-    }
 };
 
 QTEST_MAIN( TestQgsExpression )
 